{% extends "base.html" %}
{% block title %}문서 상신 | 전자결재{% endblock %}

{% block content %}
  <div class="card" style="max-width:900px; margin: 0 auto;">
    <h2 style="margin-top:0;">문서 상신</h2>

    <form method="post" enctype="multipart/form-data">
      {% csrf_token %}
      {{ form.submit_token }}

      {% if form.non_field_errors %}
        <div class="msg error">
          {{ form.non_field_errors }}
        </div>
      {% endif %}

      <div class="field">
        <label for="{{ form.title.id_for_label }}">제목</label>
        {{ form.title }}
        {% if form.title.errors %}<div class="help" style="color:#dc2626;">{{ form.title.errors }}</div>{% endif %}
      </div>

      <div class="field">
        <label for="{{ form.content.id_for_label }}">내용</label>
        {{ form.content }}
        {% if form.content.errors %}<div class="help" style="color:#dc2626;">{{ form.content.errors }}</div>{% endif %}
      </div>

      <div class="grid" style="grid-template-columns: 1fr 1fr; gap: 12px;">
        <div class="field">
          <label for="{{ form.consultants.id_for_label }}">협의자</label>
          <div class="pickbox" id="consultantsBox">
            {{ form.consultants }}
          </div>
          <div class="help">필요 시 여러 명 선택</div>
          {% if form.consultants.errors %}<div class="help" style="color:#dc2626;">{{ form.consultants.errors }}</div>{% endif %}
        </div>

        <div class="field">
          <label for="{{ form.approvers.id_for_label }}">결재자(순서대로)</label>

          <!-- ✅ 드래그 가능 리스트 래퍼 -->
          <div class="pickbox" id="approversBox" data-sortable="approvers">
            {{ form.approvers }}
          </div>

          <div class="help">{{ form.approvers.help_text }}</div>
          <div class="help" style="margin-top:6px;">
            ✅ <strong>체크 후 ↕️ 드래그로 순서를 바꾸면 결재 순서</strong>로 저장됩니다.
          </div>
          {% if form.approvers.errors %}<div class="help" style="color:#dc2626;">{{ form.approvers.errors }}</div>{% endif %}

          <!-- ✅ 서버로 순서 전달하는 Hidden Input (반드시 렌더링) -->
          {{ form.approvers_order }}
        </div>
      </div>

      <div class="field">
        <label for="{{ form.receivers.id_for_label }}">수신/열람자</label>
        <div class="pickbox" id="receiversBox">
          {{ form.receivers }}
        </div>
        <div class="help">완료 후 열람자(수신자) 목록</div>
        {% if form.receivers.errors %}<div class="help" style="color:#dc2626;">{{ form.receivers.errors }}</div>{% endif %}
      </div>

      <div class="field">
        <label for="{{ form.files.id_for_label }}">첨부파일</label>
        {{ form.files }}
        <div class="help">여러 파일 선택 가능</div>
        {% if form.files.errors %}<div class="help" style="color:#dc2626;">{{ form.files.errors }}</div>{% endif %}
      </div>

      <div class="row" style="margin-top:14px;">
        <button class="btn btn-primary" id="submitBtn" type="submit">
          <span id="submitText">상신하기</span>
          <span id="submitSpinner" style="display:none; margin-left:8px;">⏳</span>
        </button>
        <a class="btn" href="{% url 'approvals:home' %}">취소</a>
      </div>
    </form>
  </div>

  <style>
    /* ===== 공통: 박스/주변 텍스트 드래그 선택 방지 ===== */
    .pickbox, .pickbox *{
      user-select: none;
      -webkit-user-select: none;
    }

    /* CheckboxSelectMultiple 기본 ul/li 공통 스타일 */
    .pickbox ul{
      list-style:none;
      margin:0;
      padding:0;
      display:grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap:8px 12px;
    }
    @media (max-width: 860px){
      .pickbox ul{ grid-template-columns: 1fr; }
    }
    .pickbox li{ margin:0; }

    .pickbox label{
      display:flex;
      align-items:center;
      gap:10px;
      padding:10px 12px;
      border:1px solid #e5e7eb;
      border-radius:12px;
      background:#fff;
      cursor:pointer;
      line-height:1.2;
    }

    .pickbox input[type="checkbox"]{
      width:18px;
      height:18px;
      margin:0;
      flex:0 0 auto;
    }

    .pickbox label.is-checked{
      border-color:#2563eb;
      background:#eff6ff;
    }

    /* ===== 결재자(approvers)만: 드래그 UX를 위해 1열 리스트 + 핸들 ===== */
    #approversBox ul{
      display:flex;
      flex-direction:column;
      gap:8px;
    }

    #approversBox label{
      cursor:grab; /* 카드 자체 드래그 */
    }

    /* 핸들(↕️) 표시 */
    #approversBox label::before{
      content:"↕️";
      display:inline-flex;
      align-items:center;
      justify-content:center;
      width:26px;
      height:26px;
      border:1px solid #e5e7eb;
      border-radius:10px;
      background:#f9fafb;
      flex:0 0 auto;
    }

    #approversBox li.dragging label{
      opacity:0.6;
      cursor:grabbing;
    }

    #approversBox li.drag-over{
      outline:2px dashed rgba(37,99,235,0.35);
      outline-offset:2px;
      border-radius:12px;
    }
  </style>

  <script>
  document.addEventListener("DOMContentLoaded", function () {

    function syncCheckedClass(box) {
      box.querySelectorAll('input[type="checkbox"]').forEach(cb => {
        const label = cb.closest("label");
        if (!label) return;
        label.classList.toggle("is-checked", cb.checked);
      });
    }

    // ✅ 카드/라벨 드래그 시 파랗게 텍스트 선택되는 현상 방지
    function preventTextSelection(box) {
      box.addEventListener("mousedown", (e) => {
        const label = e.target.closest("label");
        if (!label) return;
        if (e.target && e.target.tagName === "INPUT") return; // 체크박스 클릭은 허용
        e.preventDefault();
      });
    }

    // ✅ 현재 DOM 순서(위→아래) 기준으로 체크된 id만 뽑기
    function getCheckedIdsInDomOrder(box) {
      const ids = [];
      const items = box.querySelectorAll("li");
      items.forEach(li => {
        const cb = li.querySelector('input[type="checkbox"]');
        if (cb && cb.checked) ids.push(String(cb.value));
      });
      return ids;
    }

    function setupSimpleBox(boxId) {
      const box = document.getElementById(boxId);
      if (!box) return;
      preventTextSelection(box);
      syncCheckedClass(box);
      box.addEventListener("change", () => syncCheckedClass(box));
    }

    function setupApproversDragSort(approversBoxId, hiddenId) {
      const box = document.getElementById(approversBoxId);
      const hidden = document.getElementById(hiddenId);
      if (!box || !hidden) return;

      const ul = box.querySelector("ul");
      if (!ul) return;

      preventTextSelection(box);
      syncCheckedClass(box);

      // ✅ 초기 hidden 값: 체크된 항목을 현재 DOM 순서대로
      hidden.value = getCheckedIdsInDomOrder(box).join(",");

      // ✅ 체크 변경 시: DOM 순서 기준으로 다시 저장
      box.addEventListener("change", function (e) {
        const cb = e.target;
        if (!cb || cb.type !== "checkbox") return;
        syncCheckedClass(box);
        hidden.value = getCheckedIdsInDomOrder(box).join(",");
      });

      // ====== Drag & Drop (HTML5 Drag API) ======
      let draggingLi = null;

      function wireDraggable() {
        ul.querySelectorAll("li").forEach(li => {
          li.setAttribute("draggable", "true");

          li.addEventListener("dragstart", (e) => {
            draggingLi = li;
            li.classList.add("dragging");
            e.dataTransfer.setData("text/plain", "drag"); // Firefox 호환
            e.dataTransfer.effectAllowed = "move";
          });

          li.addEventListener("dragend", () => {
            li.classList.remove("dragging");
            ul.querySelectorAll("li").forEach(x => x.classList.remove("drag-over"));
            draggingLi = null;

            // ✅ 드래그 종료 후: 체크된 항목 순서를 DOM 기준으로 저장
            hidden.value = getCheckedIdsInDomOrder(box).join(",");
          });

          li.addEventListener("dragover", (e) => {
            e.preventDefault();
            if (!draggingLi || draggingLi === li) return;

            li.classList.add("drag-over");

            const rect = li.getBoundingClientRect();
            const offset = e.clientY - rect.top;
            const shouldInsertBefore = offset < rect.height / 2;

            if (shouldInsertBefore) {
              if (li.previousElementSibling !== draggingLi) {
                ul.insertBefore(draggingLi, li);
              }
            } else {
              if (li.nextElementSibling !== draggingLi) {
                ul.insertBefore(draggingLi, li.nextElementSibling);
              }
            }
          });

          li.addEventListener("dragleave", () => {
            li.classList.remove("drag-over");
          });

          li.addEventListener("drop", (e) => {
            e.preventDefault();
            li.classList.remove("drag-over");
          });
        });
      }

      wireDraggable();

      // ✅ 제출 직전 최종 동기화
      const form = box.closest("form");
      if (form) {
        form.addEventListener("submit", function () {
          hidden.value = getCheckedIdsInDomOrder(box).join(",");
        });
      }
    }

    // ✅ 협의자/수신자: 체크 강조만
    setupSimpleBox("consultantsBox");
    setupSimpleBox("receiversBox");

    // ✅ 결재자: 드래그 정렬 + hidden 저장
    setupApproversDragSort("approversBox", "id_approvers_order");

    // ✅ 상신 버튼 연타 방지 + 로딩 표시
      const formEl = document.querySelector("form[enctype='multipart/form-data']");
      const btn = document.getElementById("submitBtn");
      const txt = document.getElementById("submitText");
      const sp = document.getElementById("submitSpinner");

      if (formEl && btn) {
        let submitting = false;
        formEl.addEventListener("submit", function () {
          if (submitting) return false;
          submitting = true;

          btn.disabled = true;
          btn.style.opacity = "0.7";
          btn.style.cursor = "not-allowed";
          if (txt) txt.textContent = "상신 중...";
          if (sp) sp.style.display = "inline";
        });
      }
  });
  </script>
{% endblock %}